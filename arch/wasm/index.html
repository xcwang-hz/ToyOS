<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <title>ToyOS on Wasm</title>
  <!-- SPDX-License-Identifier: GPL-2.0-only -->

  <style>
    body { 
      background: #222; 
      color: #fff;
      display: flex; 
      flex-direction: column; 
      align-items: center; 
      font-family: sans-serif;
      margin-top: 20px;
    }
    
    canvas {
      display: block;
      border: 2px solid #ffffff; /* Border for visibility */
      box-shadow: 0 0 15px rgba(0, 0, 0, 0.8);
    }

    .status {
      color: #aaa;
      margin-bottom: 10px;
      font-size: 0.9em;
    }
  </style>  
  <script>
    let nextProcessCtxPtr = 0; // Stores the pointer for the NEXT process   
    const initializedContexts = new Set(); 
    let kernelInstance = null;

    const userProcs = new Map();  // userProcId -> { instance, _start, name }
    let nextUserProcId = 1;
    let currentRunningUserProcId = 0;

    const PS2_SCANCODES = {
      "Escape": 0x01, "Digit1": 0x02, "Digit2": 0x03, "Digit3": 0x04, "Digit4": 0x05, "Digit5": 0x06, "Digit6": 0x07, "Digit7": 0x08, 
      "Digit8": 0x09, "Digit9": 0x0A, "Digit0": 0x0B, "Minus": 0x0C, "Equal": 0x0D, "Backspace": 0x0E, "Tab": 0x0F, "KeyQ": 0x10, 
      "KeyW": 0x11, "KeyE": 0x12, "KeyR": 0x13, "KeyT": 0x14, "KeyY": 0x15, "KeyU": 0x16, "KeyI": 0x17, "KeyO": 0x18, 
      "KeyP": 0x19, "BracketLeft": 0x1A, "BracketRight": 0x1B, "Enter": 0x1C, "ControlLeft": 0x1D, "KeyA": 0x1E, "KeyS": 0x1F, "KeyD": 0x20, 
      "KeyF": 0x21, "KeyG": 0x22, "KeyH": 0x23, "KeyJ": 0x24, "KeyK": 0x25, "KeyL": 0x26, "Semicolon": 0x27, "Quote": 0x28, 
      "Backquote": 0x29, "ShiftLeft": 0x2A, "Backslash": 0x2B, "KeyZ": 0x2C, "KeyX": 0x2D, "KeyC": 0x2E, "KeyV": 0x2F, "KeyB": 0x30,
      "KeyN": 0x31, "KeyM": 0x32, "Comma": 0x33, "Period": 0x34, "Slash": 0x35, "ShiftRight": 0x36, "NumpadMultiply": 0x37, "AltLeft": 0x38,
      "Space": 0x39
    };
    document.addEventListener("DOMContentLoaded", async () => {
      const log = (text) => console.log(text);

      // This is needed for SharedArrayBuffer on modern browsers.
      if (!window.crossOriginIsolated) {
        log("Error: Server did not set correct cross-origin-isolated headers.");
      }

      const canvas = document.getElementById('screen');
      const ctx = canvas.getContext('2d');
      let sharedImgData = null;

      let debugLineBuffer = "";
      // initial: 256 pages = 16MB
      // maximum: 256 pages = 16MB
      const wasmMemory = new WebAssembly.Memory({ initial: 256, maximum: 256 });

      const handleKeyEvent = (e, isDown) => {
        // console.log(`Key: ${e.code}, isDown: ${isDown}`);
        if (!kernelInstance) return;

        // Lookup the scancode map
        const scancode = PS2_SCANCODES[e.code];
        if (scancode) {
          if (e.ctrlKey || e.altKey)
             e.preventDefault(); 

          let codeToSend = scancode;
          if (!isDown)
            codeToSend |= 0x80;

          // Call the exported C++ function
          const pendingKeyAddr = kernelInstance.exports.wasm_pending_key.value; 
          const mem32 = new Int32Array(wasmMemory.buffer);
          mem32[pendingKeyAddr / 4] = codeToSend;
        } else {
          console.warn(`ToyOS_JS: Unmapped key: ${e.code}`);
        }
      };      

      function refresh() {
        ctx.putImageData(sharedImgData, 0, 0);
      }

      function createUserImports(processName) {
        return {
          env: {
            memory: wasmMemory,

            // userland calls putch -> print to the same html console
            putch: (c) => {
                const char = String.fromCharCode(c);
                // outputElement.textContent += char; 
            },
            // userland process exit
            exit: (code) => {
                console.log(`User process exited with code ${code}`);
            },

            js_syscall_handle: (func, arg1, arg2, arg3) => {
              // console.log(`[${processName}] js_syscall_handle: func=${func}, args=[${arg1}, ${arg2}, ${arg3}]`);
              if (kernelInstance.exports.asyncify_get_state() === 1)
                return 0;

              const syscallParamsAddr = kernelInstance.exports.wasm_syscall_params.value;
              const mem32 = new Int32Array(wasmMemory.buffer);
              mem32[syscallParamsAddr / 4 + 0] = func;
              mem32[syscallParamsAddr / 4 + 1] = arg1;
              mem32[syscallParamsAddr / 4 + 2] = arg2;
              mem32[syscallParamsAddr / 4 + 3] = arg3;      
              const result = kernelInstance.exports.wasm_syscall_handle();

              if (kernelInstance.exports.asyncify_get_state() === 1) {
                // Unwind Userland as well！
                const userInstance = userProcs.get(currentRunningUserProcId).instance;
                const stackPtr = userInstance.exports.wasm_user_asyncify_buffer();
                userInstance.exports.asyncify_start_unwind(stackPtr);
                return 0;
              }              

              const retval = mem32[syscallParamsAddr / 4 + 4];
              refresh();
              return retval;  
            }
          }
        };
      }      

      window.addEventListener('keydown', (e) => handleKeyEvent(e, true));
      window.addEventListener('keyup', (e) => handleKeyEvent(e, false));      

      try {
        const importObject = {
          env: {
            memory: wasmMemory,

            // [Graphics Interface]
            js_canvas_init: (ptr, width, height) => {
              const bufferSize = width * height * 4;
              const dataArray = new Uint8ClampedArray(wasmMemory.buffer, ptr, bufferSize);
              sharedImgData = new ImageData(dataArray, width, height);
            },

            js_console_error: (ptr) => {
              const mem = new Uint8Array(wasmMemory.buffer);
              let str = "";
              while (mem[ptr] !== 0) {
                  str += String.fromCharCode(mem[ptr++]);
              }
              console.error(`[RAW LOG] ${str}`);
            },

            js_context_switch: function(prevCtxPtr, nextCtxPtr) {
              // C++ requested a yield (Unwind Phase)
              if (kernelInstance.exports.asyncify_get_state() == 0) {
                console.log(`[JS] Context Switch: Save to ${prevCtxPtr}, Next is ${nextCtxPtr}`);
                kernelInstance.exports.asyncify_start_unwind(prevCtxPtr);
                initializedContexts.add(prevCtxPtr);
                nextProcessCtxPtr = nextCtxPtr;
              }
              else {
                console.log(`[JS] Process Resumed.`);
                kernelInstance.exports.asyncify_stop_rewind();
              }
            },

            js_debug_char: (ch) => {
              if (ch === 10) { // '\n' is 10
                console.log(`%c[ToyOS] ${debugLineBuffer}`, "color: #00AAFF");
                debugLineBuffer = "";
              } 
              else if (ch !== 13) {
                debugLineBuffer += String.fromCharCode(ch);
              }                
            },

	          js_load_user_process: (ptr, size) => {
              console.log(`[JS] Loading user process from 0x${ptr.toString(16)}, size ${size}`);

              // copy out .wasm from kenel memory
              // must copy, for WebAssembly.instantiate require indepedent buffer
              const kernelMem = new Uint8Array(wasmMemory.buffer);
              const wasmBytes = kernelMem.slice(ptr, ptr + size);
              if (wasmBytes[0] !== 0x00 || wasmBytes[1] !== 0x61 || 
                  wasmBytes[2] !== 0x73 || wasmBytes[3] !== 0x6d) {
                console.error("[JS] Invalid WASM magic number!");
                return -1;
              }

              const userProcId = nextUserProcId++;
              const processName = `UserProc-${userProcId}`;
              const userImports = createUserImports(processName);
              try 
              {
                const module = new WebAssembly.Module(wasmBytes);
                const instance = new WebAssembly.Instance(module, userImports);
                if (!instance.exports._start) {
                  console.error(`[JS] ${processName} has no _start export!`);
                  return -1;
                }                  

                const stackPtr = instance.exports.wasm_user_asyncify_buffer();
                console.log(`[JS] [Debug] User Stack Ptr: ${stackPtr} (0x${stackPtr.toString(16)})`);                
                userProcs.set(userProcId, {
                  instance: instance,
                  _start: instance.exports._start,
                  name: processName
                });                  
                
                console.log(`[JS] ${processName} loaded successfully`);
              } catch (e) {
                  console.error("[JS] Sync compilation failed:", e);
                  return 0;
              }
              return userProcId;
            },
            
            js_start_user_process: (userProcId) => {
              const userProc = userProcs.get(userProcId);
              if (!userProc) {
                console.error(`[JS] User process ${userProcId} not ready yet!`);
                return false;
              }
              
              currentRunningUserProcId = userProcId;
              console.log(`[JS] Starting ${userProc.name}`);

              const kernelState = kernelInstance.exports.asyncify_get_state();
              if (kernelState === 2) { // Rewinding
                  console.log(`[JS] Rewinding Userland ${userProc.name}...`);
                  const stackPtr = userProc.instance.exports.wasm_user_asyncify_buffer();
                  userProc.instance.exports.asyncify_start_rewind(stackPtr);
              }              

              try {
                userProc._start();
              } catch (e) {
                console.error(`[JS] ${userProc.name} crashed:`, e);
                return false;
              }       
              
              // if (userProc.instance.exports.asyncify_get_state() === 1) {
              //   console.log(`[JS] Userland ${userProc.name} suspended (Unwind complete).`);
              //   // Userland paused, the control goes back to Kernel
              //   // Kernel is also in the Unwinding state，and will continue its Unwind and back to JS main loop
              //   // userProc.instance.exports.asyncify_stop_unwind();
              // }          
                  
              return true;
            },
          }
        };

        const [wasmRes, cpioRes] = await Promise.all([
            fetch('toyos.wasm'),
            fetch('initramfs.cpio')
        ]);
        const wasmBuffer = await wasmRes.arrayBuffer();
        const cpioBuffer = await cpioRes.arrayBuffer();
        
        // Let's place it at 10MB (0xA00000) mark to avoid colliding with Kernel code/stack.
        // Make sure this area is managed/reserved in your kmalloc!
        const CPIO_BASE_ADDR = 0xA00000; 
        const CPIO_SIZE = cpioBuffer.byteLength;        

        // Write CPIO data into Wasm Memory
        const memView = new Uint8Array(wasmMemory.buffer);
        memView.set(new Uint8Array(cpioBuffer), CPIO_BASE_ADDR);     
        console.log(`[JS] Loaded Initramfs to 0x${CPIO_BASE_ADDR.toString(16)}, size: ${CPIO_SIZE}`);   
        
        WebAssembly.instantiate(wasmBuffer, importObject)
          .then(async obj => {
            console.log("[JS] Wasm Instantiated. Starting Kernel...");
            kernelInstance = obj.instance;
            try {
              kernelInstance.exports.wasm_entry(CPIO_BASE_ADDR, CPIO_SIZE);
              kernelInstance.exports.wasm_loop();
              refresh();
            } catch (e) {
              console.error("Kernel Error (Init):", e);
              return;
            }

            while (true) {
              if (nextProcessCtxPtr === 0)
                break;

              // Give the browser main thread a chance to render UI/handle inputs
              await new Promise(r => setTimeout(r, 0));
              
              if (initializedContexts.has(nextProcessCtxPtr)) {
                console.log(`[JS] Rewinding existing process: ${nextProcessCtxPtr}`);
                kernelInstance.exports.asyncify_start_rewind(nextProcessCtxPtr);
              }
              else {
                console.log(`[JS] Starting new process: ${nextProcessCtxPtr}`);
                if (kernelInstance.exports.asyncify_get_state() !== 0) {
                  if (kernelInstance.exports.asyncify_stop_unwind)
                    kernelInstance.exports.asyncify_stop_unwind();
                  else
                    kernelInstance.exports.asyncify_stop_rewind();
                }
              }
              
              try {
                let state = kernelInstance.exports.asyncify_get_state();
                console.log(`[JS] Calling wasm_loop state=${state}`);
                if (state !== 0) {
                  console.error("About to re-enter wasm_loop with asyncify_state =", state);
                }

                kernelInstance.exports.wasm_loop();
                refresh();

                // --- CRITICAL SAFETY CHECK ---
                // In C++-driven mode, wasm_loop should NEVER return normally (State 0).
                // It should only return via Unwind (State 1).
                state = kernelInstance.exports.asyncify_get_state();                
                if (state === 0) {
                  console.error(`[JS] CRITICAL: Kernel exited main loop!`);
                  console.error(`[JS] This means Scheduler::enter_loop returned. Stopping to prevent Double Rewind.`);                  break; 
                }
                
                // If state == 1, it yielded successfully. Loop continues.
              } catch (e) {
                console.error("Kernel Error (Loop):", e);
                break;
              }
            }
          });        
      } catch (error) {
        log("kernel failed with (" + error.name + "): " + error.message + "\n" + error.stack);
        throw error;
      }      
    }, false);
  </script>
</head>

<body>
  <div class="status" id="status">Loading ToyOS...</div>
  <canvas id="screen" width="1024" height="768"></canvas>
</body>
</html>